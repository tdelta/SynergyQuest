using System;
using UnityEngine;

/**
 * Simulates certain physics effects (e.g. knockback) without Unity's `AddForce`.
 *
 * Supported effects:
 *  1. Applying impulses (knockback)
 *  2. Setting a custom origin which will be followed
 *
 * Usage:
 *     1. Add this behavior to your game object
 *     2. Apply effects (e.g. `ApplyImpulse` method) whenever appropriate
 *     3. **ALWAYS** use the `MoveBody` method of this class for movement, not `rigidbody.MovePosition`
 * 
 * # Reasoning
 * 
 * Most of the time we want Zelda-like motion. This means we can not use the ApplyForce methods of a rigidbody to move
 * an entity, since this results in a sliding motion.
 * We can also not completely get rid of rigidbodies because we need them for handling collisions.
 * Thus we move entities in general by the "MovePosition" method of rigidbodies manually.
 *
 * This has the downside, that we can no longer apply forces to it in the few cases we actually want to, since
 * MovePosition cancels the forces out. One case where we want to apply a force is knockback on damage.
 *
 * This class simulates the application of forces / impulses by manipulating positions directly.
 * Its kind of hacky, but it seems to work.
 */
public class PhysicsEffects: MonoBehaviour
{
    // Should be 9.81 but 10 will do for us
    private const float GravitationalAcceleration = 10.0f; // m/(s^2)
    // We do not perform speed manipulations below this threshold to avoid very slow sliding
    private const float MinSpeed = 0.1f;

    // kinetic / sliding coefficient of friction
    // (https://en.wikipedia.org/wiki/Friction#Coefficient_of_friction)
    private const float frictionCoefficient = 0.7f;
    
    // Rigidbody of the object which we are applying effects to
    private Rigidbody2D _rigidbody2D;

    /**
     * One may set a transform as custom origin.
     * If set, the object affected by this PhysicsEffects instance moves relative to the transform.
     * Hence, it is also moved, if the origin moves.
     */
    private Transform _customOrigin = null;
    public Transform CustomOrigin => _customOrigin;
    // We cache the last position of the custom origin since the last update here, so that we can use it to determine
    // whether the origin moved since the last frame and by how much.
    private Vector2 _lastCustomOriginPosition;
    // Whenever the origin moved, we also need to adjust the position the physics are currently interpolating to, hence,
    // we cache that here too.
    private Vector2 _lastNextPosition;
    
    /**
     * The effects applied by this class result in additional speed changes.
     * These speed changes are recorded here.
     * 
     * Note that this an additional speed for changes on top of what is already applied by an entity controller.
     * Hence, it can for example be 0 while the entity is moving.
     */
    private Vector2 _currentSpeed = Vector2.zero;

    private void Awake()
    {
        _rigidbody2D = GetComponent<Rigidbody2D>();
        if (_customOrigin != null)
        {
            _lastCustomOriginPosition = _customOrigin.position;
        }
    }

    /**
     * Computes the deceleration generated by kinetic friction.
     * (https://en.wikipedia.org/wiki/Friction#Kinetic_friction)
     * 
     * It only applies to velocities introduced by impulse effects and does not influence the players movement otherwise.
     */
    private Vector2 ComputeFrictionDeceleration()
    {
        var mass = _rigidbody2D.mass;
        
        var normalForceMagnitude = mass * GravitationalAcceleration;
        var frictionForceMagnitude = frictionCoefficient * normalForceMagnitude;
        var deceleration = frictionForceMagnitude / mass;
        
        return -_currentSpeed.normalized * deceleration;
    }

    /**
     * Instantly transports player to new position
     */
    public void Teleport(Vector3 position)
    {
        transform.position = position;
        _rigidbody2D.position = position;
    }

    /**
     * Applies speed changes to an entities movement according to the given impulse.
     */
    public void ApplyImpulse(Vector2 impulse)
    {
        _currentSpeed += impulse / _rigidbody2D.mass;
    }

    /**
     * Sets a transform as coordinate origin for this object.
     * 
     * If set, the object affected by this PhysicsEffects instance moves relative to the transform.
     * Hence, it is also moved, if the origin moves.
     */
    public void SetCustomOrigin(Transform customOrigin)
    {
        _customOrigin = customOrigin;

        // We cache the last position of the custom origin since the last update here, so that we can use it to determine
        // whether the origin moved since the last frame and by how much.
        _lastCustomOriginPosition = customOrigin.position;
    }

    /**
     * Removes a custom origin set by `SetCustomOrigin`.
     * 
     * The object affected by this `PhysicsEffects` instance retains its world space coordinates but will no longer
     * follow the custom origin.
     */
    public void RemoveCustomOrigin()
    {
        _customOrigin = null;
    }
    
    /**
     * Applies effects to movements if there are any. If there are no effects, this is the same as calling
     * rigidbody.MovePosition, hence, **ALWAYS** use this method instead of `rigidbody.MovePosition` if you want
     * effects to apply.
     *
     * @param nextMovementPosition next position to move to. It will be appropriately altered according to current
     *                             effects. Since `rigidbody.MovePosition` is used internally, interpolation settings
     *                             of the rigidbody apply.
     */
    public void MoveBody(Vector2 nextMovementPosition)
    {
        var frictionDeceleration = ComputeFrictionDeceleration();

        // Apply friction
        //
        // Actually, we would need to ensure, that there is no sign change due to friction and clamp at 0, however,
        // together with the minimum speed logic this seems to work for now, as long as deceleration does not get too 
        // high.
        _currentSpeed += frictionDeceleration * Time.deltaTime;
        
        // Avoid slow sliding by defining a minimum effect speed
        if (Mathf.Abs(_currentSpeed.magnitude) < MinSpeed)
        {
            _currentSpeed = Vector2.zero;
        }

        nextMovementPosition += _currentSpeed * Time.deltaTime;

        _rigidbody2D.MovePosition(nextMovementPosition);
        // Cache the position the rigidbody is moving towards. We need it when a custom origin has been set, see the
        // `Update` method.
        _lastNextPosition = nextMovementPosition;
    }
    
    private void Update()
    {
        // Check whether a custom origin has been set which we must follow.
        if (!ReferenceEquals(_customOrigin, null))
        {
            var originPosition = (Vector2) _customOrigin.position;
            // Determine by how much the origin moved since last frame
            var originDelta = originPosition - _lastCustomOriginPosition;

            // We must move the physics body by that amount (hard teleport).
            // We do this in `Update` and not in `FixedUpdate` since the origin can change every frame, not only every
            // physics frame.
            _rigidbody2D.position += originDelta;
            
            // _lastNextPosition caches the position the rigidbody is currently moving towards.
            // Hence we also need to adjust it and inform the rigidbody:
            _lastNextPosition += originDelta;
            _rigidbody2D.MovePosition(_lastNextPosition);
            
            // Cache the new position of the origin
            _lastCustomOriginPosition = originPosition;
        }
    }

    public Vector2 GetImpulse()
    {
        return _currentSpeed;
    }
}
